<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JPG → WebP Optimizer (Single‑file)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0b0f14;color:#eaf2ff;margin:0}
    header{padding:18px 20px;border-bottom:1px solid #1c2533}
    h1{font-size:18px;margin:0}
    main{max-width:900px;margin:0 auto;padding:16px}
    .panel{background:#0f1624;border:1px solid #1c2533;border-radius:12px;padding:14px}
    label{font-size:12px;color:#9fb3c8}
    input[type="number"],select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #213046;background:#0e1522;color:#eaf2ff}
    .row{display:flex;gap:10px}
    .row>*{flex:1}
    .btn{display:inline-flex;align-items:center;gap:8px;background:#17314e;color:#d6ecff;border:1px solid #254a72;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600;text-decoration:none}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .list{display:grid;gap:12px;margin-top:14px}
    .item{background:#0e1522;border:1px solid #1c2533;border-radius:10px;padding:10px;display:grid;grid-template-columns:120px 1fr;gap:12px}
    .thumb{width:120px;height:80px;object-fit:cover;border-radius:8px;border:1px solid #1c2533;background:#0a101b}
    .meta{font-size:12px;color:#cbd8ea}
    .progress{height:6px;background:#101828;border:1px solid #1c2533;border-radius:999px;overflow:hidden;margin-top:12px}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#72b6ff,#8fe3ff)}
    .hint{font-size:12px;color:#9fb3c8}
  </style>
</head>
<body>
  <header><h1>JPG → WebP Optimizer (runs fully in your browser)</h1></header>
  <main>
    <div class="panel">
      <div class="row">
        <div>
          <label for="maxWidth">Max width (px)</label>
          <input id="maxWidth" type="number" value="1200" min="200" step="10" />
        </div>
        <div>
          <label for="targetKB">Target size (KB)</label>
          <input id="targetKB" type="number" value="280" min="50" step="10" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label for="minQ">Min quality</label>
          <input id="minQ" type="number" value="45" min="1" max="100" />
        </div>
        <div>
          <label for="maxQ">Max quality</label>
          <input id="maxQ" type="number" value="85" min="1" max="100" />
        </div>
      </div>
      <div style="margin-top:12px;">
        <input id="fileInput" type="file" accept="image/jpeg,image/jpg,image/png" multiple />
        <button id="process" class="btn" disabled>Process</button>
        <span id="support" class="hint"></span>
      </div>
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="hint" style="margin-top:8px;">Tip: For OpenGraph images use <strong>1200×630</strong> and <strong>200–280 KB</strong>.</div>
    </div>

    <div id="list" class="list"></div>
  </main>

<script>
(async function(){
  const $ = (q)=>document.querySelector(q);
  const fileInput = $('#fileInput');
  const processBtn = $('#process');
  const list = $('#list');
  const bar = $('#bar');
  const support = $('#support');

  const webpSupported = await checkMime('image/webp');
  support.textContent = ` · WebP support: ${webpSupported? 'yes':'no (will fallback to JPEG)'}`;

  fileInput.addEventListener('change', ()=>{
    processBtn.disabled = !fileInput.files.length;
  });

  processBtn.addEventListener('click', async ()=>{
    const files = [...fileInput.files];
    if(!files.length) return;

    const cfg = getCfg();
    list.innerHTML = '';
    bar.style.width = '0%';
    processBtn.disabled = true;

    for(let i=0;i<files.length;i++){
      const f = files[i];
      const card = renderItem(f);
      list.appendChild(card.el);

      try {
        const res = await processOne(f, cfg, webpSupported);
        card.update(res);
      } catch(err){
        card.fail(err);
      }
      bar.style.width = `${Math.round(((i+1)/files.length)*100)}%`;
    }

    processBtn.disabled = false;
  });

  function getCfg(){
    const maxWidth = +$('#maxWidth').value || 1200;
    const targetKB = +$('#targetKB').value || 280;
    const minQ = Math.min(100, Math.max(1, +$('#minQ').value || 45));
    const maxQ = Math.min(100, Math.max(minQ, +$('#maxQ').value || 85));
    return { maxWidth, targetKB, minQ, maxQ };
  }

  function renderItem(file){
    const url = URL.createObjectURL(file);
    const el = document.createElement('div');
    el.className = 'item';
    el.innerHTML = `
      <img class="thumb" src="${url}" alt="thumb" />
      <div>
        <div class="meta"><strong>${escapeHtml(file.name)}</strong></div>
        <div class="meta">Original: <strong>${fmtKB(file.size)}</strong></div>
        <div class="meta" data-role="result"></div>
        <div class="meta" data-role="err" style="color:#ffb9b9"></div>
        <div class="row" style="margin-top:8px">
          <a class="btn" data-role="dl" style="display:none;">Download</a>
        </div>
      </div>`;

    return {
      el,
      update({ blob, name, quality, reduced }){
        const res = el.querySelector('[data-role="result"]');
        const a = el.querySelector('[data-role="dl"]');
        a.style.display = 'inline-flex';
        a.href = URL.createObjectURL(blob);
        a.download = name;
        res.textContent = `Optimized: ${fmtKB(blob.size)} @ q=${quality} (↓${fmtPercent(reduced)})`;
      },
      fail(err){
        const msg = el.querySelector('[data-role="err"]');
        msg.textContent = 'Error: ' + (err && err.message ? err.message : err);
      }
    }
  }

  async function processOne(file, cfg, webpOK){
    const originalName = file.name.replace(/\.[^.]+$/, '');
    const originalSize = file.size;
    const img = await decodeWithOrientation(file); // applies EXIF orientation if available
    const { canvas, ctx, w, h } = fitToWidth(img, cfg.maxWidth);
    ctx.drawImage(img, 0, 0, w, h);

    const mime = webpOK ? 'image/webp' : 'image/jpeg';
    const { blob, q } = await encodeToTarget(canvas, mime, cfg.targetKB, cfg.minQ, cfg.maxQ);
    const reduced = (originalSize - blob.size) / originalSize;
    const ext = webpOK ? 'webp' : 'jpg';

    return { blob, name: `${originalName}.${ext}`, quality: q, reduced };
  }

  function fitToWidth(img, maxW){
    const scale = Math.min(1, maxW / img.width);
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    return { canvas, ctx, w, h };
  }

  async function encodeToTarget(canvas, mime, targetKB, loQ, hiQ){
    // quick try at max quality
    let blob = await toBlobP(canvas, mime, hiQ/100);
    if(blob.size <= targetKB*1024) return { blob, q: hiQ };

    let lo = loQ, hi = hiQ, best = null;
    while(lo <= hi){
      const mid = Math.floor((lo+hi)/2);
      const b = await toBlobP(canvas, mime, mid/100);
      if(b.size <= targetKB*1024){ best = { blob: b, q: mid }; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    if(best) return best;
    const minBlob = await toBlobP(canvas, mime, loQ/100);
    return { blob: minBlob, q: loQ };
  }

  function toBlobP(canvas, mime, q){
    return new Promise((res, rej)=> canvas.toBlob(b=> b ? res(b) : rej(new Error('toBlob failed')), mime, q));
  }

  async function decodeWithOrientation(file){
    if('createImageBitmap' in window){
      try{ return await createImageBitmap(file, { imageOrientation: 'from-image' }); }
      catch{ /* fallback below */ }
    }
    const url = URL.createObjectURL(file);
    const img = await loadImage(url); // orientation may be wrong in very old browsers
    URL.revokeObjectURL(url);
    return img;
  }

  function loadImage(url){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = ()=> resolve(img);
      img.onerror = (e)=> reject(e);
      img.src = url;
    });
  }

  async function checkMime(type){
    const c = document.createElement('canvas'); c.width=1; c.height=1; c.getContext('2d').fillRect(0,0,1,1);
    try{ const b = await toBlobP(c, type, .8); return !!b && b.type === type; }
    catch{ return false; }
  }

  function fmtKB(bytes){ return `${Math.round(bytes/1024)} KB`; }
  function fmtPercent(x){ return `${Math.max(0, Math.round(x*100))}%`; }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
})();
</script>
</body>
</html>
